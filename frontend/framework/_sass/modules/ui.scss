@use "./tools.scss";
@use "../wtk.scss";
@use "sass:map";
@use "sass:math";
@use "sass:meta";

$screen-queries: (
  ("equal", "="): width,
  ("after", ">"): min-width,
  ("before", "<"): max-width,
);

@function parse-screen-width($value) {
  @if (meta.type-of($value) != number) {
    $value: wtk.get("screen-width-breakpoints", $value);
  }

  $unit: math.unit($value);
  $value: math.div($value, $value * 0 + 1);

  @if ($unit == px) {
    @return math.div($value, 16) * 1em;
  } @else if ($unit == em or $unit == rem) {
    @return $value * 1em;
  } @else {
    @error "Unable to parse screen width.";
  }
}

@function parse-screen-query($value) {
  $data: tools.find-in-map($screen-queries, $value);

  @if ($data != null) {
    @return map.get($data, "value");
  } @else if (meta.type-of($value) == string) {
    @return $value;
  } @else {
    @error "Invalid input.";
  }
}

@mixin apply-visibility($visibility) {
  @if ($visibility == "invisible") {
    visibility: hidden !important;
  } @else if ($visibility == "hidden") {
    position: fixed !important;
    right: -200% !important;
  } @else if ($visibility == "removed") {
    display: none !important;
  }
}

@mixin respond-to-hover() {
  @media (hover: hover) {
    &:hover {
      @content;
    }
  }
}

@mixin respond-to-pointer() {
  @media (pointer: fine) {
    @content;
  }
}

@mixin respond-to-screen-width($screen-width, $screen-query: "after") {
  $screen-width: parse-screen-width($screen-width);
  $screen-query: parse-screen-query($screen-query);

  @media screen and (#{$screen-query}: #{$screen-width}) {
    @content;
  }
}
